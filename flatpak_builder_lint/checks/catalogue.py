import glob
import os
import re
import tempfile

from .. import appstream, builddir, config, ostree
from . import Check


class MetainfoCheck(Check):
    def _validate(self, path: str, appid: str, ref_type: str) -> None:
        skip = False
        if appid.endswith(config.FLATHUB_BASEAPP_IDENTIFIER) or ref_type == "runtime":
            skip = True

        appstream_path = f"{path}/app-info/xmls/{appid}.xml.gz"
        appinfo_icon_dir = f"{path}/app-info/icons/flatpak/128x128/"
        launchable_dir = f"{path}/applications"
        icon_path = f"{path}/icons/hicolor"
        svg_icon_path = f"{icon_path}/scalable/apps"
        svg_glob_path = f"{icon_path}/scalable/apps/*"
        png_glob_path = f"{icon_path}/[!scalable]*/apps/*"

        if not (skip or os.path.exists(appstream_path)):
            self.errors.add("appstream-missing-appinfo-file")
            self.info.add(
                "appstream-missing-appinfo-file: Appstream catalogue file is missing."
                + " Perhaps no Metainfo file was installed with correct name"
            )
            return

        if os.path.exists(appstream_path):
            if len(appstream.components(appstream_path)) != 1:
                self.errors.add("appstream-multiple-components")
                return

            if not appstream.is_valid_component_type(appstream_path):
                self.errors.add("appstream-unsupported-component-type")
                self.info.add(
                    "appstream-unsupported-component-type: Component type must be one of"
                    + " addon, console-application, desktop, desktop-application or runtime"
                )

            aps_cid = appstream.appstream_id(appstream_path)
            if aps_cid and aps_cid[0] != appid:
                self.errors.add("appstream-id-mismatch-flatpak-id")
                self.info.add(
                    f"appstream-id-mismatch-flatpak-id: The ID tag: {aps_cid[0]} in Metainfo"
                    + f" does not match the FLATPAK_ID: {appid}"
                )

            if not (skip or appstream.all_release_has_timestamp(appstream_path)):
                self.errors.add("appstream-release-tag-missing-timestamp")
                self.info.add(
                    "appstream-release-tag-missing-timestamp: A release tag is missing timestamp."
                    + " This is autogenerated and indicates an issue in Metainfo release tags"
                )

            aps_ctype = appstream.component_type(appstream_path)

            if aps_ctype not in config.FLATHUB_APPSTREAM_TYPES_APPS:
                return

            if not appstream.is_developer_name_present(appstream_path):
                self.errors.add("appstream-missing-developer-name")
                self.info.add(
                    "appstream-missing-developer-name: No developer tag found in Metainfo file"
                )
            if not appstream.is_project_license_present(appstream_path):
                self.errors.add("appstream-missing-project-license")
                self.info.add("appstream-missing-project-license: No project_license tag found")

            if not appstream.check_caption(appstream_path):
                self.warnings.add("appstream-screenshot-missing-caption")
                self.info.add(
                    "appstream-screenshot-missing-caption: One or more screenshots are missing"
                    + " captions in the Metainfo file"
                )

            svg_icon_list = []
            wrong_svgs = []
            if os.path.exists(svg_icon_path):
                svg_icon_list = [
                    file
                    for file in glob.glob(svg_glob_path)
                    if re.match(rf"^{appid}([-.].*)?$", os.path.basename(file))
                    and os.path.isfile(file)
                ]
                wrong_svgs = [i for i in svg_icon_list if not i.endswith((".svg", ".svgz"))]
            if not all(i.endswith((".svg", ".svgz")) for i in svg_icon_list):
                self.errors.add("non-svg-icon-in-scalable-folder")
                self.info.add(f"non-svg-icon-in-scalable-folder: {wrong_svgs}")

            png_icon_list = []
            wrong_pngs = []
            if os.path.exists(icon_path):
                png_icon_list = [
                    file
                    for file in glob.glob(png_glob_path)
                    if re.match(rf"^{appid}([-.].*)?$", os.path.basename(file))
                    and os.path.isfile(file)
                ]
                wrong_pngs = [i for i in png_icon_list if not i.endswith(".png")]

            if not all(i.endswith(".png") for i in png_icon_list):
                self.errors.add("non-png-icon-in-hicolor-size-folder")
                self.info.add(f"non-png-icon-in-hicolor-size-folder: {wrong_pngs}")

            if aps_ctype in config.FLATHUB_APPSTREAM_TYPES_DESKTOP:
                icon_list = svg_icon_list + png_icon_list
                if not len(icon_list) > 0:
                    self.errors.add("no-exportable-icon-installed")
                    self.info.add(
                        f"no-exportable-icon-installed: No PNG or SVG icons named by {appid}"
                        + " were found in /app/share/icons/hicolor/$size/apps"
                        + " or /app/share/icons/hicolor/scalable/apps"
                    )

                launchable = appstream.get_launchable(appstream_path)
                launchable_file_path = None

                if not launchable:
                    self.errors.add("metainfo-missing-launchable-tag")
                else:
                    launchable_file_path = os.path.join(launchable_dir, launchable[0])

                if not re.match(rf"^{appid}([-.].*)?[.]desktop$", launchable[0]):
                    self.errors.add("metainfo-launchable-tag-wrong-value")
                    self.info.add(
                        "metainfo-launchable-tag-wrong-value: Launchable tag in Metainfo"
                        + f" is wrong: {launchable[0]}"
                    )
                    return

                if launchable_file_path is not None and not os.path.exists(launchable_file_path):
                    self.errors.add("appstream-launchable-file-missing")
                    self.info.add(
                        f"appstream-launchable-file-missing: The launchable file {launchable[0]}"
                        + " was not found in /app/share/applications"
                    )
                    return

                # the checks below depend on launchable being present

                if not appstream.is_categories_present(appstream_path):
                    self.errors.add("appstream-missing-categories")
                    self.info.add(
                        "appstream-missing-categories: Catalogue file is missing categories."
                        + " Please check if categories are defined in the desktop file"
                        + " or in the Metainfo file and it does not have, only low"
                        + " quality categories"
                    )

                icon_filename = appstream.get_icon_filename(appstream_path)
                appinfo_icon_path = f"{appinfo_icon_dir}/{icon_filename}"

                if not os.path.exists(appinfo_icon_path):
                    self.errors.add("appstream-missing-icon-file")
                    self.info.add(
                        "appstream-missing-icon-file: No icon was generated by appstream."
                        + " An icon needs to be installed."
                        + " Allowed: 128, 256, 512px PNG or SVG"
                    )
                    return
                if not appstream.has_icon_key(appstream_path):
                    self.errors.add("appstream-missing-icon-key")
                    return
                if appstream.icon_no_type(appstream_path):
                    self.errors.add("appstream-icon-key-no-type")
                if not appstream.is_remote_icon_mirrored(appstream_path):
                    self.errors.add("appstream-remote-icon-not-mirrored")
                    self.info.add(
                        "appstream-remote-icon-not-mirrored: Remote icons are not mirrored"
                        + " to Flathub"
                    )

    def check_build(self, path: str) -> None:
        ref_type, appid = builddir.infer_type(path), builddir.infer_appid(path)
        if not (appid and ref_type):
            return

        self._validate(f"{path}/files/share", appid, ref_type)

    def check_repo(self, path: str) -> None:
        for ref in ostree.get_all_refs_filtered(path):
            parts = ref.split("/")
            ref_type, appid = parts[0], parts[1]

            if not (appid and ref_type):
                return

            with tempfile.TemporaryDirectory() as tmpdir:
                for subdir in ("app-info", "applications", "icons"):
                    os.makedirs(os.path.join(tmpdir, subdir), exist_ok=True)
                    ostree.extract_subpath(
                        path, ref, f"files/share/{subdir}", os.path.join(tmpdir, subdir), True
                    )

                self._validate(tmpdir, appid, ref_type)
